#!/usr/bin/env zsh
###################################################
# swatch: stow watch
# Watch for changes on a specified directory
# and stow/unstow directories inside each one of them
# if necessary
###################################################

# Source dot and use it as a library
. $DOT_PATH/bin/dot

# Enforce proper usage
if [[ -z $1 ]]; then
    echo "Usage: $0 <path_to_dir>"; exit 1
fi

_log() {
    echo "$stow_dir: $1"
}

stow_dir=$1 # the directory itself to be stowed
stow_dir_scantime=2 # directory scan freqyency
inotify_events="create,delete,move,delete_self,move_self"

# This script will insist on probing its target directory
# until it actually exists to proceed with its actual job.
# This is done, so your symlink population plan does not get
# jeopardized because of a not created directory previous to
# the execution of this assistant
while [[ ! -d $stow_dir ]]; do
    _log "directory not found, trying again in $stow_dir_scantime second(s) ..."
    sleep $stow_dir_scantime
done

# log the thing
_log "found, proceeding to stow watch"

# Any changes inside sync directory will be stowed
# into the home directory
while inotifywait --syslog @.stfolder -r \
    -e $inotify_events $stow_dir > /dev/null
do
    _log "changes detected!, stowing all directories ..."

    # check whether there are no left directories
    # to stow
    if [[ -z $(ls $stow_dir) ]]; then
        _log "directory is empty, stow cancelled!"
        symlinks -d $HOME # delete all dangling symlinks left
        continue
    fi

    # stow each dir in stow_dirs
    for dir in $stow_dir/*; do
        _log "stow $stow_dir => $(basename $dir)"
        _dot_stow $stow_dir $(basename $dir) &> /dev/null
    done
    unset dir

    # send the actual notification
    if [[ ! -z "$DISPLAY" ]]; then
        notify-send "syncd @ $stow_dir" "All directories synced and stowed!"
    fi
done
