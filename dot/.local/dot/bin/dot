#!/usr/bin/env zsh
#########################################
# dot: an utility for dotfiles management
#########################################

autoload dot_printf
autoload dot_printf_err
autoload dot_printf_setup
autoload dot_printf_uninstall
autoload dot_printf_warn
autoload dot_printf_clean


#########################################
# Essential variables
#########################################
dot_basedir=${DOT_PATH}/lib/dot
dot_installers_dir=${dot_basedir}/install.d
dot_prestow_dir=${dot_basedir}/pre-stow.d
dot_poststow_dir=${dot_basedir}/post-stow.d
dot_preunstow_dir=${dot_basedir}/pre-unstow.d
dot_postunstow_dir=${dot_basedir}/post-unstow.d
dot_update_dir=${dot_basedir}/update.d
dot_ansible_playbook_dir=${HOME}/.ansible

#
# Update all the things!
#
dot_update() {
    if [[ -z $1 ]]; then
        # With no arguments, this will execute all update jobs
        # located inside dot_update_dir
        for update_job in $dot_update_dir/*; do
            if [ ! -h $update_job ]; then
                dot_printf_warn "==> UPDATING: $(basename $update_job)"
                . $update_job
                _dot_update_exec
                # make sure the callback function is removed afterwards
                unset -f _dot_update_exec
            fi
        done
        unset update_job
    else
        # Update a single thing
        update_job=${dot_update_dir}/$1
        if [[  -a $update_job  ]]; then
            dot_printf_warn "==> UPDATING: $1"
            . $update_job
            _dot_update_exec
            # make sure the callback function is removed afterwards
            unset -f _dot_update_exec
        fi
    fi
}

_dot_stow() {
    local stow_dir=$1
    for i in "${@:2}"; do
        dot_printf "Stowing $i"
        # pre-stow invocation
        [ -e ${dot_prestow_dir}/$i ] && . ${dot_prestow_dir}/$i

        # Try to find the package inside dotfiles directory
        [ -d ${stow_dir}/$i ] && stow --verbose=1 -R -d $stow_dir -t $HOME $i

        # post-stow invocation
        [ -e ${dot_poststow_dir}/$i ] && . ${dot_poststow_dir}/$i
    done
}

_dot_unstow() {
    local stow_dir=$1
    for i in "${@:2}"; do
        dot_printf "Unstowing $i"
        # preunstow invocation
        [ -e ${dot_preunstow_dir}/$i ] && . ${dot_preunstow_dir}/$i

        # Try to find the package inside dotfiles directory
        [ -d ${stow_dir}/$i ] && stow --verbose=1 -D -d $stow_dir -t $HOME $i

        # postunstow invocation
        [ -e ${dot_postunstow_dir}/$i ] && . ${dot_postunstow_dir}/$i
    done
}


#
# This will automatically unstow directories inside $DOT_HOME
#
dot_stow() {
    _dot_stow $DOT_HOME "$@"
}

#
# This will automatically unstow directories inside $DOT_HOME
#
dot_unstow() {
    _dot_unstow $DOT_HOME "$@"
}

#
# Execute ansible playbook to deploy system-wide changes
#
dot_deploy() {
    dot_printf "Deploying playbook changes ..."
    cd $dot_ansible_playbook_dir && \
        ansible-galaxy install --force -r requirements.yml && \
        ansible-playbook site.yml -i inventory || exit 1
}

#
# Stow/install packages inside DOT_HOME
#
dot_install() {
    if [ -x ${dot_installers_dir}/$1 ]; then
        # install the actual thing
        dot_printf "Launching installer: $1"
        ${dot_installers_dir}/$1 ${@:3}
    fi
    if [ -d ${DOT_HOME}/$1 ]; then
        dot_stow $1 || exit 1
    fi
}

#
# Print help
#
dot_print_help() {
    echo "Usage: dot <COMMAND> <ARGUMENTS>"
    echo
    echo "  dot stow   <package> - stow package(s)"
    echo "  dot unstow <package> - unstow package(s)"
    echo "  dot update <package> - update specific configurations"
    echo "  dot purge            - purge every dotfile there is inside your home directory"
    echo
}



#
# Purge all symlinks and dangling files inside $HOME directory
#
dot_purge() {
    ############################
    # warn the user first of all
    ############################
    dot_printf_warn "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
    dot_printf_warn "-------------------------------------------------------"
    dot_printf_warn "This is really going to assf*ck your home directory ..."
    dot_printf_warn "It will unstow everything, remove any remaining"
    dot_printf_warn "dotfiles inside your home directory"
    dot_printf_warn "NOTE: SET DRY_PURGE=1 IF YOU WANT TO SIMULATE THIS COMMMAND"
    dot_printf_warn "-------------------------------------------------------"
    dot_printf_warn "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
    dot_printf_warn "ARE YOU REALLY SURE ABOUT THIS? (y/N)> "
    read -sq ans
    [ $ans != 'y' ] && dot_printf "Aborting operation ..." &&  exit 0
    unset ans

    #####################
    # check for DRY_PURGE
    #####################
    if [[ ! -z "$DRY_PURGE" ]]; then
        dot_printf_warn "Dry purge mode is ON"
    fi

    ########################################
    # unstow all directories inside DOT_HOME
    ########################################
    dot_printf "Unstowing all packages inside $DOT_HOME"
    for d in $DOT_HOME/*; do
        if [[ -z "$DRY_PURGE" ]]; then
            dot_unstow $( basename $d )
        else
            dot_printf "DRY_PURGE: unstow ==> $(basename $d)"
        fi
    done
    unset d

    ########################################################
    # dot_ignore includes all folders/files not to be purged
    ########################################################
    dot_ignore="${HOME}/.dotignore"
    if [[ -a ${HOME}/.dotignore ]]; then
        dot_printf_warn "~/.dotignore file found!, proceeding to read its entries ..."
        ignore_files=$(cat ${HOME}/.dotignore | tr '\n' ' ')
        if [[ ! -z "$ignore_files" ]]; then
            for f in $(echo $ignore_files); do
                # all directories are considered to be relative
                # to the $HOME directory
                dot_ignore="$dot_ignore ${HOME}/${f}"
            done
            unset f
        fi
        unset ignore_files
    fi

    #######################################################
    # unstow all directories inside all specified STOW_DIRS
    #######################################################
    stow_dirs=$(echo $STOW_DIRS | tr ':' ' ')
    if [[ ! -z "$stow_dirs" ]]; then
        for stow_dir in $(echo $stow_dirs); do
            dot_printf_warn "Unstowing all packages inside $stow_dir"
            stow_subdirs=$(echo $stow_dir/*) &> /dev/null
            if [[ ! -z "$stow_subdirs" ]]; then
                for d in $(echo $stow_subdirs); do
                    if [[ -z "$DRY_PURGE" ]]; then
                        _dot_unstow $stow_dir $(basename $d)
                    else
                        dot_printf "DRY_PURGE: STOW_DIRS unstow ==> $(basename $d)"
                    fi
                done
                unset d
            fi
            unset stow_subdirs
            # all STOW_DIRS are ignored for purging
            # Reason: there could be dotfolders being treated and sync dirs
            # it wouldn't be nice to treat them as spare dotfolders/files
            dot_ignore="$dot_ignore $stow_dir"
        done
        unset stow_dir
    fi
    unset stow_dirs

    # print list of files to be ignored
    if [[ ! -z "$DRY_PURGE" ]]; then
        dot_printf_warn "Ignore list is:"
        for f in $(echo $dot_ignore); do
            dot_printf "==> $f"
        done
    fi

    # Purge every dotfile thereis in your home directory
    dot_printf_warn "Purging all your dotfiles inside your home directory at $HOME"
    if [[ -z "$DRY_PURGE" ]]; then
        sudo rm $DOT_HOME
    fi

    #################################################
    # Perform the actual deletion of dotfiles/folders
    # with the clear exception of those ignored
    #################################################
    dotfiles=$(echo $HOME/.*) &> /dev/null
    if [[ ! -z "$dotfiles" ]]; then
        for rd in $(echo $dotfiles); do
            if test "${dot_ignore#*$rd}" != "$dot_ignore"; then
                dot_printf_warn "$rd on dotignore list, therefore not deleted"
                continue
            fi
            dot_printf "Deleting $rd"
            if [[ -z "$DRY_PURGE" ]]; then
                sudo rm -rf $rd # if not ignored, then purge it
            fi
        done
        unset rd
    fi
    unset dotfiles

    ###############
    # Tell the user to reboot system
    ###############
    dot_printf_warn "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
    dot_printf_warn "-------------------------------------------------------"
    dot_printf_warn "Your system has been purged from this dotfiles and"
    dot_printf_warn "therefore ready for a clean install of your Debian OS"
    dot_printf_warn "-------------------------------------------------------"
    dot_printf_warn "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
}

################
# The main thing
################
if [[ $ZSH_EVAL_CONTEXT == 'toplevel' ]]; then
    # I'm not being sourced!, so ...
    case $1 in
        install)
            dot_install ${@:2}
            ;;
        stow)
            dot_stow ${@:2}
            ;;
        deploy)
            dot_deploy
            ;;
        unstow)
            dot_unstow ${@:2}
            ;;
        update)
            dot_update ${@:2}
            ;;
        purge)
            dot_purge ${@:2}
            ;;
        *)
            dot_print_help; exit 1
            ;;
    esac
    dot_printf "Done!"
    exit 0
fi
